
FEATURES:
- maybe use placeInfoBatch (1 big half-hour availability json for all dates, all courts)
    - use it for quick-scan, i.e. to see which days are fully booked
- use timeInfoBatch for crawling
    - use to check there are free courts of desired time (e.g. 19:00 weekdays or 17:00 weekends)
    - if we have ExtensionInterest, see if there is a new court with desired ExtensionInterest (and at least 1 hr time)
    - if not, make a timeInfoBatch call with held courtID and see if there is 30min availability
- cache
    - old cache had
        - half-hour slot array (from 18:00 till 20:00 I think)
        - aggregate reservation data
    - new cache should have
        - booked time (duration?) -- more flexible than half-hour slots
        - booked courtID          -- not aggregate, allows implementing proper extension interest
- extension interest
    - now only 30 mins extension implemented. Do incrementally earler/later extension aattempts (with floor/ceiling)
        - actually, a gradually degradding favorable thing should be attempted. Floor/ceiling is necessary (for weekday and weekend)
        - but also priority list e.g. I'll do 18:00 if I need to but I'd rather change court/venue to make it 18:30

- ability to have arbitrary from-to time bracket (like we have EARLY_BIRD, LATE_OWL) for weekdays and for weekends (or for any weekday, or even for specific Desire?)
- for <48-hour purchase-only (vs. reserve with ability to cancel) cases. Sometimes they are 90-min- or 120-min- only, because seller decided to not sell in pieces.
     In these cases need to attempt to make 60-, 90-, and 120- minute requests, because they will not appear in 60-min aviable durations

- stdo --> logger
    - migration to logger
    - debugMode migration to logger level
    - log "searching for reservation" with higher level
    - log REST logs with lower elvel

- first:
    - add cap for weekends. I don't want my 16:30 LATER desire to yield 18:30 suggestions
    - clay courts that have priority: courts 1, 5 most in the shade have priority. next, courts 2, 6 have priority because they're next-best courts in shade, etc.
-- later
    - minikube (mini kubernetes)




-- Design conflict
        Currently:
            - DesireMaker makes desires (and validates for duplicates)
            - Crawler passes desires to DesireIteratorThingy, which gets all orders, and
            - passes 1 desire + all orders to Prospect finder (loop)
            - which does stuff (including matching Order to Desire via Prospect.getOrder())
        Next:
            + remove Desire duplication validation from DesireMaker (later, for now should not regress, so it's fine) -- not removed. Added to it, even. Duplication embraced now.
            + keep validation in DesireOrderPairer. Motivation:
                - DesireMaker can only check for duplicate Desires (it only knows desires)
                - DesireOrderPairer can validate
                    - duplicate Desires
                    - stray Orders (Orders that are not matched with Desires)
                    - stray Desires -- ensures proper matching
                    - multiple Desires and multiple Orders -- finds ambiguous mappings and fails if found
            + remove Prospect.getOrder() and similar order-inferring logic from Prospect class
            + nice to have: rename Prospect to Vacancy
            - maybe: get rid of DesireIteratorThingy? Or merge it with crawler. Crawler only does "do work", kind of too little responsibility.
 -- Next++: adapt booking itself
        ? make current (single-booking) work strictly -- if inside, then search for inside only -- done?
        + make double booking simply by allowing another desire for same day with different court ids (may automatically work at this point) -- it did work automatically
        + search for and remove:  // todo remove redundant desire infra
        + calendar: make half-circle for 1/2 desires. Or Circle outline for 1/2 and filled-in circle for 2/2
        - make convenience methods
            - make 1 entry in DesiresExplicit to make NONE for all day (both court types)
            - debug mode print desires not like this
               -- Desire: Desire(date=2025-05-28, extensionInterest=NONE,
              courts=[1, 7, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 135, 137, 139, 141, 143, 145, 147, 59, 61, 63, 65, 67, 69],
               order=Order(date=2025-05-28, court=H09, timeFrom=19:30, timeTo=20:30))
             but like this:
               -- Desire: Desire(2025-05-28, extensionInterest=NONE, courts=Inside, order=Order(2025-05-28, court=H09, 19:30-20:30))
            - make calendar from
                  - ◐ = IN or OUT
                  - ● means IN+OUT
                to
                  - ◐ means IN only, and
                  - ◑ means OUT only, and
                  - ● means IN+OUT
            - for summer, default desire maker with INSIDE = NONE because inside usually easy to get if needed
        - refactor: move all the stubbing/mocking helper methods from DesireIteratorThingyTest to base class and make it extend it.
 -- Even more Next: nice to haves
    - for summer, pick clay courts in the shade first
    - for winter, pick hard first, then carpet. Or maybe remove 2 booking-per-day limit and allow e.g. priority queue:
        - first new hards, then old hards, not-3-6-9-public ones, carpet ones, finally, if none above found, search for all other courts.
        